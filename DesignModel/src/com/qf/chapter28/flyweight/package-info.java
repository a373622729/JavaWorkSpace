/**
 * Created by ios on 16/11/20.
 */
package com.qf.chapter28.flyweight;

/**
 *  服务器报内存溢出:
 *      1.代码中逻辑的问题
 *      2.产生的对象太多,没有内存来分配对象了
 *
 *  解决2的问题， 使用一种共享技术减少对象数量. 对象池 1.容器定义  2,提供客户端访问的接口
 *      相同的属性提取出来,不同的在系统内进行赋值处理
 */


/**
 *  享元模式:
 *      是池技术重要的实现方式
 *      使用共享对象可以有效地支持大量的细粒度的对象
 *
 *      要求细粒度对象,那就将这些对象的信息分为两个部分: 内部状态和外部状态
 *
 *      内部状态:
 *          是对象可以共享出来的信息.存储在享元对象内部并且不回随环境改变而改变的.,如这个例子中的id.postAddress等,他们可以作为一个对象的动态附加信息,不必直接存储在某个具体的对象中.
 *      外部状态:
 *          是对象得以依赖的一个标记,是随着环境改变而改变的,不可以共享的状态,如 这个例子中的考试科目+ 考试地点符合的字符串,他是一批对象的统一标识,是唯一的一个索引值.
 */


/**
 *  使用场景:
 *      1.系统中存在大量的相似对象
 *      2.细粒度的对象都具备较接近的外部状态,而且内部状态与环境无关,也就是说对象没有特定身份
 *      3.需要缓冲池的场景
 */

/**
 *  对象池着重在对象的复用上,池中的每个对象是可以替换的,从同一个池中获得A对象和B对象,对客户端来说是完全相同的,他主要解决复用
 *  而享元模式在主要解决的是对象的共享问题,如何建立多个可以共享的细粒度对象则是其关注的重点
 */